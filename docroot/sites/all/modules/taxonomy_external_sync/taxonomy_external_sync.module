<?php

use Drupal\taxonomy_external_sync\plugin\source\VocBenchRDFSource;
use Drupal\taxonomy_external_sync\plugin\source\FaolexSource;

require_once 'includes/SourceInterface.inc';
require_once 'includes/VocBenchRDFSource.inc';
require_once 'includes/FaolexSource.inc';
require_once 'taxonomy_external_sync.admin.inc';

/**
 * Implements hook_form_alter().
 */
function taxonomy_external_sync_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  $form += taxonomy_external_sync_taxonomy_form_element($form, $form_state);
  $form['#validate'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_validate';
  $form['#submit'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_submit';
}


/**
 * Implements hook_entity_info_alter().
 */
function taxonomy_external_sync_entity_info_alter(&$entity_info) {
  $info = taxonomy_external_sync_config_load();
  foreach ($entity_info['taxonomy_term']['bundles'] as $bundle => &$config) {
    if (!empty($info[$bundle])) {
      $config['tes'] = $info[$bundle];
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function taxonomy_external_sync_entity_load($entities, $type) {
  $config = taxonomy_external_sync_config_load();
  foreach ($entities as $entity) {
    if (!empty($entity->machine_name) && !empty($config[$entity->machine_name])) {
      $entity->tes = $config[$entity->machine_name];
    }
  }
}

function taxonomy_external_sync_source_plugins() {
  $ret = array();
  $plugins = module_invoke_all('taxonomy_external_sync_source_plugin');
  foreach($plugins as $plugin) {
    if ($plugin && is_object($plugin)) {
      $ret[get_class($plugin)] = $plugin;
    }
  }
  drupal_alter('taxonomy_external_sync_source_plugin', $ret);
  return $ret;
}


/**
 * Implements hook_taxonomy_external_sync_source_plugin().
 */
function taxonomy_external_sync_taxonomy_external_sync_source_plugin() {
  $vb = new VocBenchRDFSource();
  $test = new \Drupal\taxonomy_external_sync\plugin\DummySourcePlugin();
  $faolex = new FaolexSource();
  return array(
    $vb,
    $test,
    $faolex,
  );
}


function taxonomy_external_sync_get_taxonomy_fields($bundle) {
  $ret = array();
  foreach (field_info_fields() as $field_name => $field) {
    if (!empty($field['bundles']['taxonomy_term'])
      && in_array($bundle, $field['bundles']['taxonomy_term'])) {
      $info = field_info_instance('taxonomy_term', $field_name, $bundle);
      $ret[$field_name] = $info['label'] . ' (' . $field_name . ')';
    }
  }
  ksort($ret);
  return $ret;
}

/**
 * Get the configuration for a single vocabulary.
 *
 * @param $vocabulary
 *  Vocabulary machine name.
 *
 * @return mixed
 *  Array containing the configuration or FALSE if the configuration doesn't
 * exist.
 */
function taxonomy_external_sync_get_configuration($vocabulary) {
  $q = db_select('taxonomy_external_sync')
    ->fields(NULL, array('configuration'))
    ->condition('bundle', $vocabulary)
    ->execute()
    ->fetchField();
  $config = unserialize($q);
  return $config;
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_validate($form, $form_state) {
  ///
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_submit($form, $form_state) {
  if ($bundle = $form_state['values']['machine_name']) {
    if ($tes_enable = !empty($form_state['values']['tes_enable'])) {
      $config = array(
        'enable' => $tes_enable,
        'plugin' => $form_state['values']['tes_plugin'],
        'mappings' => array()
      );
      // Mappings
      $destination_fields = taxonomy_external_sync_get_taxonomy_fields($bundle);
      foreach ($destination_fields as $field_name => $label) {
        if (!empty($form_state['values']['tes_' . $field_name])) {
          $config['mappings'][$field_name] = $form_state['values']['tes_' . $field_name];
        }
      }
      // Plugin config
      foreach($form_state['values'] as $k => $v) {
        if (preg_match('/tes\_plugin\_config\_/', $k)) {
          $key = substr($k, 18);
          $config['plugin_config'][$key] = $v;
        }
      }
      taxonomy_external_sync_config_save($bundle, $config);
    }
    else {
      taxonomy_external_sync_config_save($bundle, array());
    }
  }
}

function taxonomy_external_sync_config_load() {
  $mappings = db_select('taxonomy_external_sync')
    ->fields(NULL, array('bundle', 'configuration'))
    ->execute()
    ->fetchAllKeyed();
  foreach ($mappings as $bundle => $mapping) {
    $mappings[$bundle] = unserialize($mapping);
  }
  return $mappings;
}

/**
 * Saves an taxonomy configuration to the database.
 *
 * @param string $bundle
 *   Bundle to save configuration
 *
 * @return
 *   Status flag indicating the outcome of the operation.
 */
function taxonomy_external_sync_config_save($bundle, $config) {
  $status = db_merge('taxonomy_external_sync')
    ->key(array('bundle' => $bundle))
    ->fields(array('configuration' => serialize($config),))
    ->execute();
  entity_info_cache_clear();
  return $status;
}

/**
 * Synchronizes a vocabulary if TES is configured.
 *
 * @param $vocabulary
 *  Vocabulary machine name.
 */
function taxonomy_external_sync_migrate_vocabulary($vocabulary) {
  $config = taxonomy_external_sync_get_configuration($vocabulary);
  if ($config == FALSE) {
    watchdog('taxonomy_external_sync', t('Could not find TES configuration for \'@voc\' vocabulary', array('@voc' => $vocabulary)), NULL, WATCHDOG_ERROR);
    return;
  }
  if ($config['enable'] == FALSE) {
    return;
  }
}