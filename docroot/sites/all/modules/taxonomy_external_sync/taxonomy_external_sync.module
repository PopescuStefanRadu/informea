<?php

use Drupal\taxonomy_external_sync\plugin\source\VocBenchRDFSource;
use Drupal\taxonomy_external_sync\plugin\source\FaolexSource;

require_once 'includes/SourceInterface.inc';
require_once 'includes/VocBenchRDFSource.inc';
require_once 'includes/FaolexSource.inc';
require_once 'taxonomy_external_sync.admin.inc';

/**
 * Implements hook_form_alter().
 */
function taxonomy_external_sync_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  $form += taxonomy_external_sync_taxonomy_form_element($form, $form_state);
  $form['#validate'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_validate';
  $form['#submit'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_submit';
}


/**
 * Implements hook_entity_info_alter().
 */
function taxonomy_external_sync_entity_info_alter(&$entity_info) {
  $info = taxonomy_external_sync_config_load();
  foreach ($entity_info['taxonomy_term']['bundles'] as $bundle => &$config) {
    if (!empty($info[$bundle])) {
      $config['tes'] = $info[$bundle];
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function taxonomy_external_sync_entity_load($entities, $type) {
  $config = taxonomy_external_sync_config_load();
  foreach ($entities as $entity) {
    if (!empty($entity->machine_name) && !empty($config[$entity->machine_name])) {
      $entity->tes = $config[$entity->machine_name];
    }
  }
}

function taxonomy_external_sync_source_plugins() {
  $ret = array();
  $plugins = module_invoke_all('taxonomy_external_sync_source_plugin');
  foreach($plugins as $plugin) {
    if ($plugin && is_object($plugin)) {
      $ret[get_class($plugin)] = $plugin;
    }
  }
  drupal_alter('taxonomy_external_sync_source_plugin', $ret);
  return $ret;
}


/**
 * Implements hook_taxonomy_external_sync_source_plugin().
 */
function taxonomy_external_sync_taxonomy_external_sync_source_plugin() {
  $vb = new VocBenchRDFSource();
  $test = new \Drupal\taxonomy_external_sync\plugin\DummySourcePlugin();
  $faolex = new FaolexSource();
  return array(
    $vb,
    $test,
    $faolex,
  );
}


function taxonomy_external_sync_get_taxonomy_fields($bundle) {
  $ret = array();
  foreach (field_info_fields() as $field_name => $field) {
    if (!empty($field['bundles']['taxonomy_term'])
      && in_array($bundle, $field['bundles']['taxonomy_term'])) {
      $info = field_info_instance('taxonomy_term', $field_name, $bundle);
      $ret[$field_name] = $info['label'] . ' (' . $field_name . ')';
    }
  }
  ksort($ret);
  return $ret;
}

/**
 * Get the configuration for a single vocabulary.
 *
 * @param $vocabulary
 *  Vocabulary machine name.
 *
 * @return mixed
 *  Array containing the configuration or FALSE if the configuration doesn't
 * exist.
 */
function taxonomy_external_sync_get_configuration($vocabulary) {
  $q = db_select('taxonomy_external_sync')
    ->fields(NULL, array('configuration'))
    ->condition('bundle', $vocabulary)
    ->execute()
    ->fetchField();
  $config = unserialize($q);
  return $config;
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_validate($form, $form_state) {
  ///
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_submit($form, $form_state) {
  if ($bundle = $form_state['values']['machine_name']) {
    if ($tes_enable = !empty($form_state['values']['tes_enable'])) {
      $config = array(
        'enable' => $tes_enable,
        'plugin' => $form_state['values']['tes_plugin'],
        'mappings' => array()
      );
      // Mappings
      $destination_fields = taxonomy_external_sync_get_taxonomy_fields($bundle);
      foreach ($destination_fields as $field_name => $label) {
        if (!empty($form_state['values']['tes_' . $field_name])) {
          $config['mappings'][$field_name] = $form_state['values']['tes_' . $field_name];
        }
      }
      // Plugin config
      foreach($form_state['values'] as $k => $v) {
        if (preg_match('/tes\_plugin\_config\_/', $k)) {
          $key = substr($k, 18);
          $config['plugin_config'][$key] = $v;
        }
      }
      taxonomy_external_sync_config_save($bundle, $config);
    }
    else {
      taxonomy_external_sync_config_save($bundle, array());
    }
  }
}

function taxonomy_external_sync_config_load() {
  $mappings = db_select('taxonomy_external_sync')
    ->fields(NULL, array('bundle', 'configuration'))
    ->execute()
    ->fetchAllKeyed();
  foreach ($mappings as $bundle => $mapping) {
    $mappings[$bundle] = unserialize($mapping);
  }
  return $mappings;
}

/**
 * Saves an taxonomy configuration to the database.
 *
 * @param string $bundle
 *   Bundle to save configuration
 *
 * @return
 *   Status flag indicating the outcome of the operation.
 */
function taxonomy_external_sync_config_save($bundle, $config) {
  $status = db_merge('taxonomy_external_sync')
    ->key(array('bundle' => $bundle))
    ->fields(array('configuration' => serialize($config),))
    ->execute();
  entity_info_cache_clear();
  return $status;
}

function taxonomy_external_sync_migrate_all_vocabularies() {
  $configs = taxonomy_external_sync_config_load();
  foreach ($configs as $bundle => $config) {
    taxonomy_external_sync_migrate_vocabulary($bundle, $config);
  }
}

function _taxonomy_external_sync_get_singlevalued_field_value($value) {
  if (is_array($value)) {
    if (array_key_exists('en', $value)) {
      return $value['en'];
    }
    elseif (array_key_exists(LANGUAGE_NONE, $value)) {
      return $value[LANGUAGE_NONE];
    }
    else {
      return (reset($value));
    }
  }
  return $value;
}

/**
 * Synchronizes a vocabulary if TES is configured.
 *
 * @param $bundle
 *  Vocabulary machine name.
 */
function taxonomy_external_sync_migrate_vocabulary($bundle, $config = NULL) {
  $vocabulary = taxonomy_vocabulary_machine_name_load($bundle);
  $languages   = array_keys(language_list());
  $terms_created = $terms_processed = 0;
  if ($config == NULL) {
    $config = taxonomy_external_sync_get_configuration($bundle);
  }
  if ($config === FALSE) {
    watchdog('taxonomy_external_sync', t('Could not find TES configuration for \'@voc\' vocabulary', array('@voc' => $bundle)), NULL, WATCHDOG_ERROR);
    return;
  }
  if ($config['enable'] == FALSE) {
    return;
  }
  $mappings = $config['mappings'];
  if (empty($source_name_field = $mappings['name_field']) && empty($source_name_field = $mappings['name'])) {
    watchdog('taxonomy_external_sync', t('NAME field mapping is not configured for \'@voc\' vocabulary', array('@voc' => $bundle)), NULL, WATCHDOG_ERROR);
    return;
  }
  $destination_name_field = array_search($source_name_field, $mappings);
  try {
    /** @var \Drupal\taxonomy_external_sync\plugin\SourceInterface $plugin */
    $plugin = new $config['plugin']($config['plugin_config']);
    $id_field = $plugin->getIdField();
    $terms = $plugin->getTerms();

    $q = db_select('taxonomy_external_sync_map', 't')
      ->fields('t', array('source_id', 'destination_tid'));
    $term_mappings = $q->execute()->fetchAllKeyed();
    foreach ($terms as $term) {
      $translations = array();
      $is_new = FALSE;
      if (!property_exists($term, $id_field)) {
        // TODO: Maybe log an warning message here?
        continue;
      }
      $id_field_value = _taxonomy_external_sync_get_singlevalued_field_value($term->{$id_field});
      try {
        if (array_key_exists($id_field_value, $term_mappings)) {
          // Term already exists.
          $drupal_term = taxonomy_term_load($term_mappings[$id_field_value]);
        }
        else {
          $drupal_term = new \stdClass();
          $is_new = TRUE;
          $terms_created++;
        }
        $original_sha1 = sha1(json_encode($drupal_term));
        $drupal_term->name = _taxonomy_external_sync_get_singlevalued_field_value($term->{$source_name_field});
        $drupal_term->vid = $vocabulary->vid;
        foreach ($mappings as $destination_field => $source_field) {
          // TODO: Check field values setting on multivalued fields!!!!!!!!!!!!!
          if (property_exists($term, $source_field)) {
            if (is_array($term->{$source_field}) && !is_numeric(key($term->{$source_field}))) {
              if (!property_exists($drupal_term, $destination_field)) {
                $drupal_term->{$destination_field} = array();
              }
              if (!array_key_exists(LANGUAGE_NONE, $term->{$source_field})) {
                if (is_array($drupal_term->{$destination_field}[LANGUAGE_NONE])) {
                  $drupal_term->{$destination_field}[LANGUAGE_NONE][0]['value'] = $term->{$source_field}['en'];
                }
                else {
                  $drupal_term->{$destination_field}[LANGUAGE_NONE] = array(
                    array(
                      'value' => $term->{$source_field}['en'],
                    )
                  );
                }
              }
              foreach ($term->{$source_field} as $lang => $value) {
                if (in_array($lang, $languages)) {
                  $translations[] = $lang;
                  if (is_array($drupal_term->{$destination_field}[$lang])) {
                    $drupal_term->{$destination_field}[$lang][0]['value'] = $value;
                  }
                  else {
                    $drupal_term->{$destination_field}[$lang] = array(
                      array(
                        'value' => $value,
                      )
                    );
                  }
                }
              }
            }
            else {
              $drupal_term->{$destination_field} = $term->{$source_field};
            }
          }
        }

        $sha1 = sha1(json_encode($drupal_term));
        if ($original_sha1 != $sha1) {
          if ($is_new) {
            taxonomy_term_save($drupal_term);
            db_insert('taxonomy_external_sync_map')
              ->fields(array(
                'source_id' => $id_field_value,
                'destination_tid' => $drupal_term->tid,
              ))
              ->execute();
          }

          $translations = array_unique($translations);
          // Set term translations
          $translation_handler = entity_translation_get_handler('taxonomy_term', $drupal_term);
          $translation_handler->setOriginalLanguage(LANGUAGE_NONE);
          $translation_handler->initTranslations();
          $drupal_term->translations = $translation_handler->getTranslations();
          foreach ($languages as $language) {
            if (in_array($language, $translations)) {
              $translation_handler->setTranslation(array(
                'translate' => 0,
                'status' => 1,
                'uid' => 1,
                'language' => $language,
                'source' => LANGUAGE_NONE,
              ));
            }
          }
          taxonomy_term_save($drupal_term);
          $terms_processed++;
        }
      }
      catch (\Exception $e) {
        watchdog('taxonomy_external_sync', t('Error migrating term \'@term\' in \'@voc\' vocabulary', array('@term' => $id_field_value, '@voc' => $bundle)), NULL, WATCHDOG_ERROR);
        watchdog_exception('taxonomy_external_sync', $e);
      }
    }
  }
  catch (\Exception $e) {
    watchdog_exception('taxonomy_external_sync', $e);
  }
  watchdog(
    'taxonomy_external_sync',
    t('Successfully synchronized \'@voc\' vocabulary. Processed @np terms: @nc created, @nu updated',array('@voc' => $bundle, '@np' => $terms_processed, '@nc' => $terms_created, '@nu' => ($terms_processed - $terms_created))),
    NULL,
    WATCHDOG_INFO
  );
}
