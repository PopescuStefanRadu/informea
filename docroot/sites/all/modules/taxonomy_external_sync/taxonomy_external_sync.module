<?php

use Drupal\taxonomy_external_sync\plugin\source\VocBenchRDFSource;
use Drupal\taxonomy_external_sync\plugin\source\FaolexSource;

require_once 'includes/SourceInterface.inc';
require_once 'includes/VocBenchRDFSource.inc';
require_once 'includes/FaolexSource.inc';
require_once 'taxonomy_external_sync.admin.inc';

/**
 * Implements hook_form_alter().
 */
function taxonomy_external_sync_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  $form += taxonomy_external_sync_taxonomy_form_element($form, $form_state);
  $form['#validate'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_validate';
  $form['#submit'][] = 'taxonomy_external_sync_form_taxonomy_form_vocabulary_submit';
}


/**
 * Implements hook_entity_info_alter().
 */
function taxonomy_external_sync_entity_info_alter(&$entity_info) {
  $info = taxonomy_external_sync_config_load();
  foreach ($entity_info['taxonomy_term']['bundles'] as $bundle => &$config) {
    if (!empty($info[$bundle])) {
      $config['tes'] = $info[$bundle];
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function taxonomy_external_sync_entity_load($entities, $type) {
  $config = taxonomy_external_sync_config_load();
  foreach ($entities as $entity) {
    if (!empty($entity->machine_name) && !empty($config[$entity->machine_name])) {
      $entity->tes = $config[$entity->machine_name];
    }
  }
}

function taxonomy_external_sync_source_plugins() {
  $ret = array();
  $plugins = module_invoke_all('taxonomy_external_sync_source_plugin');
  foreach($plugins as $plugin) {
    if ($plugin && is_object($plugin)) {
      $ret[get_class($plugin)] = $plugin;
    }
  }
  drupal_alter('taxonomy_external_sync_source_plugin', $ret);
  return $ret;
}


/**
 * Implements hook_taxonomy_external_sync_source_plugin().
 */
function taxonomy_external_sync_taxonomy_external_sync_source_plugin() {
  $vb = new VocBenchRDFSource();
  $test = new \Drupal\taxonomy_external_sync\plugin\DummySourcePlugin();
  $faolex = new FaolexSource();
  return array(
    $vb,
    $test,
    $faolex,
  );
}


function taxonomy_external_sync_get_taxonomy_fields($bundle) {
  $ret = array();
  foreach (field_info_fields() as $field_name => $field) {
    if (!empty($field['bundles']['taxonomy_term'])
      && in_array($bundle, $field['bundles']['taxonomy_term'])) {
      $info = field_info_instance('taxonomy_term', $field_name, $bundle);
      $ret[$field_name] = $info['label'] . ' (' . $field_name . ')';
    }
  }
  ksort($ret);
  return $ret;
}

/**
 * Get the configuration for a single vocabulary.
 *
 * @param $vocabulary
 *  Vocabulary machine name.
 *
 * @return mixed
 *  Array containing the configuration or FALSE if the configuration doesn't
 * exist.
 */
function taxonomy_external_sync_get_configuration($vocabulary) {
  $q = db_select('taxonomy_external_sync')
    ->fields(NULL, array('configuration'))
    ->condition('bundle', $vocabulary)
    ->execute()
    ->fetchField();
  $config = unserialize($q);
  return $config;
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_validate($form, $form_state) {
  ///
}

function taxonomy_external_sync_form_taxonomy_form_vocabulary_submit($form, $form_state) {
  if ($bundle = $form_state['values']['machine_name']) {
    if ($tes_enable = !empty($form_state['values']['tes_enable'])) {
      $config = array(
        'enable' => $tes_enable,
        'plugin' => $form_state['values']['tes_plugin'],
        'mappings' => array()
      );
      // Mappings
      $destination_fields = taxonomy_external_sync_get_taxonomy_fields($bundle);
      foreach ($destination_fields as $field_name => $label) {
        if (!empty($form_state['values']['tes_' . $field_name])) {
          $config['mappings'][$field_name] = $form_state['values']['tes_' . $field_name];
        }
      }
      // Plugin config
      foreach($form_state['values'] as $k => $v) {
        if (preg_match('/tes\_plugin\_config\_/', $k)) {
          $key = substr($k, 18);
          $config['plugin_config'][$key] = $v;
        }
      }
      taxonomy_external_sync_config_save($bundle, $config);
    }
    else {
      taxonomy_external_sync_config_save($bundle, array());
    }
  }
}

function taxonomy_external_sync_config_load() {
  $mappings = db_select('taxonomy_external_sync')
    ->fields(NULL, array('bundle', 'configuration'))
    ->execute()
    ->fetchAllKeyed();
  foreach ($mappings as $bundle => $mapping) {
    $mappings[$bundle] = unserialize($mapping);
  }
  return $mappings;
}

/**
 * Saves an taxonomy configuration to the database.
 *
 * @param string $bundle
 *   Bundle to save configuration
 *
 * @return
 *   Status flag indicating the outcome of the operation.
 */
function taxonomy_external_sync_config_save($bundle, $config) {
  $status = db_merge('taxonomy_external_sync')
    ->key(array('bundle' => $bundle))
    ->fields(array('configuration' => serialize($config),))
    ->execute();
  entity_info_cache_clear();
  return $status;
}

/**
 * Synchronizes a vocabulary if TES is configured.
 *
 * @param $bundle
 *  Vocabulary machine name.
 */
function taxonomy_external_sync_migrate_vocabulary($bundle) {
  $vocabulary = taxonomy_vocabulary_machine_name_load($bundle);
  $config = taxonomy_external_sync_get_configuration($bundle);
  $mappings = $config['mappings'];
  if ($config == FALSE) {
    watchdog('taxonomy_external_sync', t('Could not find TES configuration for \'@voc\' vocabulary', array('@voc' => $bundle)), NULL, WATCHDOG_ERROR);
    return;
  }
  if ($config['enable'] == FALSE) {
    return;
  }
  try {
    /** @var \Drupal\taxonomy_external_sync\plugin\SourceInterface $plugin */
    $plugin = new $config['plugin']($config['plugin_config']);
    $id_field = $plugin->getIdField();
    if (empty($mappings[$id_field])) {
      watchdog('taxonomy_external_sync', t('Mapping of ID field missing for \'@voc\' vocabulary', array('@voc' => $bundle)), NULL, WATCHDOG_ERROR);
      return;
    }
    $terms = $plugin->getTerms();

    $table = 'field_data_' . $id_field;
    $q = db_select($table, 't')
      ->fields('t', array($id_field . '_value', 'entity_id'))
      ->condition('t.entity_type', 'taxonomy_term')
      ->condition('t.bundle', $bundle);
    $drupal_terms = $q->execute()->fetchAllKeyed();
    foreach ($terms as $term) {
      $translations = array();
      if (!property_exists($term, $mappings[$id_field]) ||
        (empty($term->{$mappings[$id_field]}['en']) && empty($term->{$mappings[$id_field]}[LANGUAGE_NONE]))) {
        // TODO: Maybe log an warning message here?
        continue;
      }
      if (is_array($term->{$mappings[$id_field]})) {
        $id_field_value = !empty($term->{$mappings[$id_field]}['en']) ? $term->{$mappings[$id_field]}['en'] : $term->{$mappings[$id_field]}[LANGUAGE_NONE];
      }
      else {
        $id_field_value = $term->{$mappings[$id_field]};
      }
      if (array_key_exists($id_field_value, $drupal_terms)) {
        // Term already exists.
        $drupal_term = taxonomy_term_load($drupal_terms[$id_field_value]);
      }
      else {
        $drupal_term = new \stdClass();
        watchdog('taxonomy_external_sync', t('Creating new term \'@term\' within \'@voc\' vocabulary', array('@term' => $id_field_value, '@voc' => $bundle)), NULL, WATCHDOG_INFO);
      }
      $drupal_term->name = $id_field_value;
      $drupal_term->vid = $vocabulary->vid;
      foreach ($mappings as $destination_field => $source_field) {
        // TODO: Check field values setting on multivalued fields!!!!!!!!!!!!!
        if (property_exists($term, $source_field)) {
          if (is_array($term->{$source_field}) && !is_numeric(key($term->{$source_field}))) {
            if (!property_exists($drupal_term, $destination_field)) {
              $drupal_term->{$destination_field} = array();
            }
            if (!array_key_exists(LANGUAGE_NONE, $term->{$source_field})) {
              $drupal_term->{$destination_field}[LANGUAGE_NONE] = array(
                array(
                  'value' => $term->{$source_field}['en'],
                )
              );
            }
            foreach ($term->{$source_field} as $lang => $value) {
              $translations[] = $lang;
              $drupal_term->{$destination_field}[$lang] = array(
                array(
                  'value' => $value,
                )
              );
            }
          }
          else {
            $drupal_term->{$destination_field} = $term->{$source_field};
          }
        }
      }
      $translations = array_unique($translations);
      $languages   = array_keys(language_list());
      // Set term translations
      $translation_handler = entity_translation_get_handler('taxonomy_term', $drupal_term);
      $translation_handler->setOriginalLanguage(LANGUAGE_NONE);
      $translation_handler->initTranslations();
      $entity->translations = $translation_handler->getTranslations();
      foreach ($languages as $language) {
        if (in_array($language, $translations)) {
          $translation_handler->setTranslation(array(
            'translate' => 0,
            'status' => 1,
            'uid' => 1,
            'language' => $language,
            'source' => LANGUAGE_NONE,
          ));
        }
      }
      taxonomy_term_save($drupal_term);
    }
  }
  catch (\Exception $e) {
    watchdog_exception('taxonomy_external_sync', $e);
  }
}
